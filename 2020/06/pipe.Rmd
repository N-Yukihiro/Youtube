---
title: "初めてのパイプ演算子"
output: html_notebook
---

### パイプ演算子を利用した例

パイプ演算子を利用して実際に平均の算出を行う.
総和を求めるためにsum()関数を, 割り算を行うためにmagrittrパッケージのdivide_by()関数を利用する.
divide_by()関数の第1引数に割られる数を, 第2引数に割る数を指定する.

```{r}
library(magrittr)
x <- 1:10
n <- 10
## パイプを使わない例
magrittr::divide_by(sum(x), n)
```

パイプ演算子を利用しない場合と比較して, どういう過程を経たいのかが明確になっている

```{r}
## パイプを利用した例
sum(x) %>% 
  divide_by(n)
```


### パイプ演算子を利用した例2

パイプ演算子を利用する場合, コードの始点に利用するデータ自体を書くこともできる.

```{r}
x %>% 
  sum() %>% 
  divide_by(n)
```

関数の中でパイプ演算子を利用することもできる.

```{r}
x %>% 
  sum() %>% 
  divide_by(x %>% 
              length())
```

### パイプ演算子を利用して第2引数以降に結果を渡す

tidyverseパッケージに含まれる関数は第1引数に実行するデータを指定する場合が多く, パイプ演算子が利用しやすい.

しかし, それ以外のパッケージに含まれる関数では, 第2引数以降にデータを指定することもある.
そのままではパイプ演算子が使えない.
第2引数以降にデータを渡すには, データを渡したい場所に.を記す.

```{r}
x %>% 
  length() %>% 
  divide_by(sum(x),
            .)
```

### .を利用する際の注意

回帰分析を行うlm()関数などでは, .の違う利用法が定義されている.
第1引数の中で使われている.は応答変数以外の変数を説明変数に投入することを意図している.
第2引数の中では, パイプ演算子で受け取ったデータをどこに渡すのかを表している.
どのような意図で.を書いているのかに注意!

```{r}
iris %>% 
  lm(formula = Petal.Length ~ .,
     data = .)
```

### 複数の関数を同時に実行したい

パイプ演算子を利用して, 複数の関数をまとめて実行したい場合は{}で囲む.
データを与える位置は.を利用して明示する.
{}内で最後に実行する関数以外はprint()関数を一緒に実行すると安全.

```{r}
iris %>% {
  names(.) %>% print()
  str(.)
  }
```

### 任意の結果のみをオブジェクトに格納する

任意の結果のみをオブジェクトに格納するためには, 永続代入<<-を利用する.
オブジェクトに格納した結果は表示されないので注意.

```{r}
iris %>% {
  names(.) %>% print()
  h <<- head(., 3)
  str(.)
}
h
```

### 複数の関数の同時実行とggplot2

ggplot2パッケージを利用する場合, 2つの選択肢がある.
1つはprint()関数の中でグラフを描く.
もう1つはさらに{}でグラフを描くコードを囲みパイプでprint()関数に渡す.

```{r}
library(ggplot2)
iris %>% 
  {
    print(
      ggplot(.) +
        aes(Petal.Length) +
        geom_histogram())
    str(.)
  }
```

両方とも実行結果は同じ.

```{r}
iris %>% 
  {
    {ggplot(.) +
        aes(Petal.Length) +
        geom_histogram()} %>% 
      print() 
    str(.)
  }
```


### パイプ演算子に似た演算子

magrittrパッケージには, パイプ(%>%)演算子の他に3つの似た演算子を用意している.
%T>%演算子, %$%演算子や%<>%演算子がある.
はじめから無理に利用しなくても良い.

### %T>%演算子

%>%の途中経過をチラ見したい場合には%T>%演算子を利用する.
チラ見とはグラフを描きだしたり, 表を書いたりすることを指す.
チラ見した結果は, その後には引き渡されない(スキップされる).
チラ見をする関数は同時に複数関数を実行する際と同様に{}とprint()関数を利用すると安全.

```{r}
iris %T>% 
  {names(.) %>% 
      print()} %>% 
  head() %>% 
  str()
```

### %T>%演算子とオブジェクトへの格納

オブジェクトに結果を格納したいが, チラ見した結果は格納したくない場合には, 最後に%T>%演算子を利用する.

```{r}
d <- iris %>%
  head(3) %T>% 
  {print(str(.))}
d
```

### %$%(dollar)演算子

Rにデフォルトで格納されているirisデータのPetal.Lengthという列の平均値を算出する.
```{r}
mean(iris$Petal.Length)
```

データフレームの列名の指定が必要な場合などでは, %$%演算子を利用することが有効.

```{r}
iris %$% 
  mean(Petal.Length)
```

### 標本分散の計算

Rには標本分散を計算する関数はない.
自身で計算するにはかなり読みづらいコードになる.

```{r}
mean((iris$Petal.Length - mean(iris$Petal.Length))^2)
```

パイプ演算子を利用することで読みやすく書き換えることができる.
    
```{r}
iris %$% 
  subtract(Petal.Length,
           Petal.Length %>% 
             mean()) %>% 
  raise_to_power(2) %>% 
  mean()
```

両方とも実行している内容は同じ.

```{r}
iris %$% 
  `-`(Petal.Length, 
      Petal.Length %>% 
        mean()) %>% 
  `^`(2) %>% 
  mean()
```

### %$%演算子と複数処理

%$%演算子を利用する場合に複数の関数を同時に実行したい場合には, {}で囲む.
コツは通常のパイプ演算子と同じ.

```{r}
iris %$% {
  var(Sepal.Length) %>% 
    print()
  sd(Sepal.Length)
}
```


### %<>%演算子

実行した結果を元のオブジェクトに代入しなおしてオブジェクトをアップデートしたい場合には%<>%を使う.

```{r head, echo=TRUE}
iris %<>% 
  head(3) %>% 
  names()
iris
```